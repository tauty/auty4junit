= Introduction =
auty4junitは、テスト結果を自動的に生成することでテストの高い生産性を実現する、JUnit補助ツールです。<br>
TDDやBDDには向きませんが、先にコーディングを行うスタイルで開発を進める場合や、テストコードのないレガシーコードをリファクタリングする場合に力強い味方となります。<br>
auty4junitでは、通常のテスト向けのAutyクラスと、RDBMSを使ったテスト向けのAutyDBクラスの二つを使って開発を進めていきます。

= Autyクラスの使い方 =

== 基本的な使い方 ==

Autyクラスは、RDBMSを使わないテストで使用します。<br>
Autyクラスの使い方は極めて簡単です。例えば下記のようなコードを書いたとします。<br>

{{{
package sample;

import static tetz42.test.Auty.*;

import java.util.HashMap;
import java.util.Map;

import org.junit.Test;

public class ATest {

	static class Sample {
		int intField1;
		int intField2;
		String strField1;
		String strField2;
		Map<String, String> mapField = new HashMap<String, String>();
	}

	@Test
	public void atest() {
		Sample sample = new Sample();
		sample.intField1 = 101;
		sample.intField2 = 102;
		sample.strField1 = "文字列１";
		sample.strField2 = "文字列２";
		sample.mapField.put("key1", "value1");
		sample.mapField.put("key2", "value2");
		sample.mapField.put("key3", "value3");

		assertEqualsWithFile(sample, getClass(), "atest");
	}
}
}}}

Autyクラスのメソッドは、最後から3行目の_assertEqualsWithFile _です。<br>
このテストクラスを実行すると、一回目はテストケースが失敗して下記のような失敗メッセージが出力されます。<br>
{{{
java.lang.AssertionError: No file found. The actual string has been output to the path:
test\sample\expected\ATest\atest.txt
 The contents of the file are as follows:
Sample{
	intField1 = 101
	intField2 = 102
	strField1 = "文字列１"
	strField2 = "文字列２"
	mapField = HashMap{
		"key1": "value1"
		"key2": "value2"
		"key3": "value3"
	}
}
	at org.junit.Assert.fail(Assert.java:91)
	at tetz42.test.Auty.assertEqualsWithFile(Auty.java:132)
	at sample.ATest.atest(ATest.java:31)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                       :
                       :
}}}

このとき、あなたがやるべきことは、上記メッセージの「The contents of the file are as follows:」の下に表示された内容をチェックすることです。<br>
見ての通り、こちらには_assertEqualsWithFile _の第一パラメータとして渡したオブジェクトのdump結果が表示されています。もし内容に問題がなければ、そのままテストケースを再実行してください。<br>
今度はテストが成功するはずです。<br>
<br>
それでは、今度はテストをわざと失敗させてみましょう。<br>
テストクラスの「atest」メソッドのsample.strField1に値を代入する処理を、下記のように書き換えて見ます。

{{{
		sample.strField1 = "string1";
}}}

この状態でテストを再度実行するとテストが失敗して、下記のような失敗メッセージが表示されます。

{{{
java.lang.AssertionError: Actual data does not match! Check the diff message below:
  expected -> '-', actual -> '+' 

00001|Sample{
00002|	intField1 = 101
00003|	intField2 = 102
00004|-	strField1 = "文字列１"
00004|+	strField1 = "string1"
00005|	strField2 = "文字列２"
00006|	mapField = HashMap{
00007|		"key1": "value1"
00008|		"key2": "value2"
00009|		"key3": "value3"
00010|	}
00011|}

You can ignore this assertion error to append parameters at 'assertEqualsWithFile' method like below:
assertEqualsWithFile(foo, getClass(), "file_name", 4);

	at org.junit.Assert.fail(Assert.java:91)
	at tetz42.test.Auty.assertSameStrings(Auty.java:240)
	at tetz42.test.Auty.assertEqualsWithFile(Auty.java:122)
	at sample.ATest.atest(ATest.java:31)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                       :
                       :
}}}

メッセージ内の行番号の右に「-」が表示されているのが期待値、「+」が表示されているのが実際の値です。<br>
実際の開発ではこのdiff情報を元に、テスト対象のソースを直すのか、テストクラスを直すのか、テスト結果を直すのかを選択して対処を行うことになります。<br>
auty4junitを使った開発でもテスト対象やテストクラスの修正は通常と全く同じですので、ここでは、テスト結果を直す対処法について説明します。<br>
<br>
_assertEqualsWithFile _によりテスト結果は、<br>
　　_test/第二パラメータのクラスオブジェクトのパッケージ/expected/第二パラメータのクラスオブジェクトのクラス名/第三パラメータのファイル名.txt_<br>
にテキストファイルとして出力されます。<br>
今回のケースでは、<br>
　　_test/sample/expected/ATest/atest.txt_<br>
が出力結果となります。ここで取り得る手は三つあります。<br>
最初が上記ファイルを普通にエディタで開いて、手作業で修正する手です。今回のケースのように修正量が少なければ、この方法が手っ取り早いでしょう。<br>

次に、上記ファイルを削除してやり直す方法です。auty4junitでは上記ファイルが存在しなければ初回のテストだと判断しますので、再度dump結果を上記ファイルとして出力させることができます。上記diffメッセージのみで新しく出力されるテスト結果が正しいと判断できる場合に有効です。<br>

最後が、失敗時に出力されるdumpファイルを利用する方法です。<br>
_assertEqualsWithFile _では生成されたdumpファイルとのマッチングでテストケースが失敗した場合、<br>
　　_test/第二パラメータのクラスオブジェクトのパッケージ/failed/第二パラメータのクラスオブジェクトのクラス名/第三パラメータのファイル名.txt_<br>
というパスに新しくdumpした結果のテキストファイルを出力します。<br>
今回のケースでは、<br>
　　_test/sample/failed/ATest/atest.txt_<br>
というファイルがそれになります。<br>
これをテキストエディタで開いて、内容に問題がなければこのファイルで上記expectedフォルダ以下のファイルを上書きします。<br>

上記三つのいずれかの方法でテスト結果を修正あとに再度テストケースを実行すると、今度はテストが成功するはずです。

== 特定行の無視 ==

次に、下記のようなコードを例に考えてみます。

{{{
package sample2;

import static tetz42.test.Auty.*;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.junit.Test;

public class ATest {

	static class Sample {
		int intField1;
		int intField2;
		String strField1;
		String strField2;
		Map<String, String> mapField = new HashMap<String, String>();
	}

	@Test
	public void atest() {
		Sample sample = new Sample();
		sample.intField1 = 101;
		sample.intField2 = 102;
		sample.strField1 = "文字列１";
		sample.strField2 = "文字列２";
		sample.mapField.put("key1", "value1");
		sample.mapField.put("key2", "value2");
		sample.mapField.put("key3", "value3");
		sample.mapField.put("now", new Date().toString());

		assertEqualsWithFile(sample, getClass(), "atest");
	}
}
}}}

こちらを実行すると、下記のような失敗メッセージが表示されます。

{{{
java.lang.AssertionError: No file found. The actual string has been output to the path:
test\sample2\expected\ATest\atest.txt
 The contents is below:
Sample{
	intField1 = 101
	intField2 = 102
	strField1 = "文字列１"
	strField2 = "文字列２"
	mapField = HashMap{
		"key1": "value1"
		"key2": "value2"
		"key3": "value3"
		"now": "Mon Aug 20 10:28:52 JST 2012"
	}
}
	at org.junit.Assert.fail(Assert.java:91)
	at tetz42.test.Auty.assertEqualsWithFile(Auty.java:133)
	at sample2.ATest.atest(ATest.java:33)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                       :
                       :
}}}

ここまでは前回の例と同じですが、再度テストケースを実行すると前回とは違いテストが失敗してしまい、下記のような失敗メッセージが表示されます。

{{{
java.lang.AssertionError: Actual data does not match! Check the diff message below:
  expected -> '-', actual -> '+' 

00001|Sample{
00002|	intField1 = 101
00003|	intField2 = 102
00004|	strField1 = "文字列１"
00005|	strField2 = "文字列２"
00006|	mapField = HashMap{
00007|		"key1": "value1"
00008|		"key2": "value2"
00009|		"key3": "value3"
00010|-		"now": "Mon Aug 20 10:28:52 JST 2012"
00010|+		"now": "Mon Aug 20 10:31:54 JST 2012"
00011|	}
00012|}

You can ignore this assertion error to append parameters at 'assertEqualsWithFile' method like below:
assertEqualsWithFile(foo, getClass(), "file_name", 10);

	at org.junit.Assert.fail(Assert.java:91)
	at tetz42.test.Auty.assertSameStrings(Auty.java:241)
	at tetz42.test.Auty.assertEqualsWithFile(Auty.java:123)
	at sample2.ATest.atest(ATest.java:33)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                       :
                       :
}}}

原因はソースの最後から5行目の、

{{{
		sample.mapField.put("now", new Date().toString());
}}}
です。システム日時を文字列化した値を代入しているので、実行の度に値が変わってしまっています。<br>
テスト対象オブジェクト内部に上記のようにシステム日時由来の値やランダム値、新規採番されたIDなど実行の度に変わってしまう値が含まれていることは通常の開発で良くあることです。<br>
auty4junitではこのような事態に対応するために、特定の行を無視してマッチングを行わないようにする手段を設けています。<br>
上記失敗メッセージ中に、_「You can ignore this assertion error to append parameters at 'assertEqualsWithFile' method like below:」_ と書かれている箇所があるのに気が付いたでしょうか？この下に、下記のように書かれています。
{{{
assertEqualsWithFile(foo, getClass(), "file_name", 10);
}}}

この第4パラメータの数値は、無視する行番号を表しています。この指示に従い、テストクラスの_assertEqualsWithFile _を使用している箇所を下記のように書き換えます。

{{{
		assertEqualsWithFile(sample, getClass(), "atest", 10);
}}}

上記のようにしてテストを再実行すると、今度はテストが成功するはずです。<br>
なお無視されるのは上記の例では10行目だけですので、他の値はちゃんとチェックされます。<br>


= AutyDBクラスの使い方 =
※AutyDBは現在ベータ版で、将来インターフェースが大きく変わる可能性があるので、ご注意下さい。<br>

RDBMSと連携するJUnitのテストクラスを作成する場合には、AutyDBを使います。<br>

RDBMSを使った単体テストは、一般に下記のような流れでテストを実施します。
 # 現在スキーマにあるデータをバックアップしてから削除。
 # テストデータをスキーマにロードする。
 # テスト対象コードの実行。
 # テスト結果の検証。
 # テストデータを削除し、1. にてバックアップしたデータを復元

AutyDBクラスを使うと上記は、下記のようなコードで実現することになります。

{{{
package sample;

import static tetz42.test.AutyDB.*;

import java.sql.Connection;
import java.sql.SQLException;

import org.junit.AfterClass;
import org.junit.Test;

import tetz42.test.Proc;

public class ADBTest {

	@Test
	public void atest() throws Exception {

		// 呪文･･･
		useConnection(new Proc() {

			@Override
			// 呪文･･･
			public void run(Connection con) throws Exception {

				// 上記1, 2 指定されたテーブルのデータバックアップ ＆ テストデータ読込
				prepareDB(ADBTest.class, "atest", "TABLE_A");
				
				// 上記1, 2 指定されたテーブルのデータバックアップ ＆ データ削除
				deleteDB(ADBTest.class, "atest", "TABLE_B");

				// 上記3 テスト対象の実行
				TestTarget.moveDatasFromTableAToTableB(con);

				// 上記4 指定されたテーブルが空っぽであることの検証
				assertZero(ADBTest.class, "atest", "TABLE_A");
				
				// 上記4 指定されたテーブルが保存されたテスト結果と一致しているか検証
				assertDB(ADBTest.class, "atest", "TABLE_B");
			}
		});
	}

	@AfterClass
	public static void bye() throws SQLException {
		// 上記5 バックアップされたデータの復元
		restoreAll();
	}
}
}}}

prepareDB, deleteDB, assertZero, assertDBはAutyDBクラスのメソッドで、パラメータは全て、<br>
 * 第一パラメータ ･･･ クラスオブジェクト(テストデータの特定用)
 * 第二パラメータ ･･･ テストケース名(テストデータの特定用)
 * 第三パラメータ以降 ･･･ テーブル名(複数指定可)
となっています。<br>

ここでは上記で指定されたTABLE_A, TABLE_Bがともにプライマリキーの「id」と、テキストデータが入った「text」という列を持っていて、それぞれ下記に示すデータが格納されていると仮定して、開発の流れを説明します。

<table border="1">
  <tr><th colspan="2">TABLE_A</th></tr>
  <tr><th>id</th><th>text</th></tr>
  <tr><td>1</td><td>いち</td></tr>
  <tr><td>2</td><td>にい</td></tr>
  <tr><td>3</td><td>秋刀魚の</td></tr>
  <tr><td>4</td><td>尻尾</td></tr>
  <tr><td>5</td><td>ゴリラの</td></tr>
  <tr><td>6</td><td>息子</td></tr>
  <tr><td>7</td><td>菜っ葉</td></tr>
  <tr><td>8</td><td>葉っぱ</td></tr>
  <tr><td>9</td><td>腐った</td></tr>
  <tr><td>10</td><td>豆腐</td></tr>
<table>

<table border="1">
  <tr><th colspan="2">TABLE_B</th></tr>
  <tr><th>id</th><th>text</th></tr>
  <tr><td>1</td><td>一献</td></tr>
  <tr><td>2</td><td>二献</td></tr>
  <tr><td>3</td><td>三献です。</td></tr>
<table>

== テストデータの準備 ==
まず最初にテストクラスを実行すると、テストケースが失敗して下記失敗メッセージが出力されます。

{{{
java.lang.AssertionError: No test case data found. Tried to insert some datas as test case data.
Please check it by the SQL below:
SELECT * FROM ZUTY_TABLE_A WHERE ZUTY_TESTCASE_NAME = 'atest.prepare#sample.ADBTest'
If you don't like it, delete it by the SQL below:
DELETE FROM ZUTY_TABLE_A WHERE ZUTY_TESTCASE_NAME = 'atest.prepare#sample.ADBTest'
	at org.junit.Assert.fail(Assert.java:91)
	at tetz42.test.AutyDB.restore(AutyDB.java:219)
	at tetz42.test.AutyDB.restore(AutyDB.java:206)
	at tetz42.test.AutyDB.prepareDB(AutyDB.java:62)
	at sample.ADBTest$1.run(ADBTest.java:26)
	at tetz42.test.AutyDB.useConnection(AutyDB.java:53)
	at sample.ADBTest.atest(ADBTest.java:19)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                      :
                      :
}}}

この時、スキーマを確認すると「ZUTY_TABLE_A」というテーブルが新たに生成されているはずです。これはprepareDBメソッド内の処理にて、テストデータ及びバックアップデータを格納するために自動的に生成したテーブルです。

上記テスト失敗メッセージの中に、
{{{
SELECT * FROM ZUTY_TABLE_A WHERE ZUTY_TESTCASE_NAME = 'atest.prepare#sample.ADBTest'
}}}
というSELECT文が出力されています。これをスキーマ上で実行すると下記のようなデータが得られるはずです。

<table border="1">
  <tr><th colspan="3">ZUTY_TABLE_A</th></tr>
  <tr><th>zuty_testcase_name</th><th>id</th><th>text</th></tr>
  <tr><td>atest.prepare#sample.ADBTest</td><td>1</td><td>いち</td></tr>
  <tr><td>atest.prepare#sample.ADBTest</td><td>2</td><td>にい</td></tr>
  <tr><td>atest.prepare#sample.ADBTest</td><td>3</td><td>秋刀魚の</td></tr>
  <tr><td>atest.prepare#sample.ADBTest</td><td>4</td><td>尻尾</td></tr>
  <tr><td>atest.prepare#sample.ADBTest</td><td>5</td><td>ゴリラの</td></tr>
  <tr><td>atest.prepare#sample.ADBTest</td><td>6</td><td>息子</td></tr>
  <tr><td>atest.prepare#sample.ADBTest</td><td>7</td><td>菜っ葉</td></tr>
  <tr><td>atest.prepare#sample.ADBTest</td><td>8</td><td>葉っぱ</td></tr>
  <tr><td>atest.prepare#sample.ADBTest</td><td>9</td><td>腐った</td></tr>
  <tr><td>atest.prepare#sample.ADBTest</td><td>10</td><td>豆腐</td></tr>
<table>

ここで、上記例でのprepareDBメソッドの動作を詳しく説明します。
 * TABLE_Aに対するテストデータ＆バックアップデータ保存用のテーブルの「ZUTY_TABLE_A」が存在しないとき、生成する。
 * TABLE_Aの現在のデータを、テスト起動時のシステム日時を文字列化した値をzuty_testcase_nameに指定して、バックアップとしてZUTY_TABLE_Aに保存する。
 * 『[テストケース名].prepare#[クラスオブジェクトのフルパス名]』という文字列を生成し、ZUTY_TESTCASE_NAMEに生成した文字列が格納されているデータがあれば、TABLE_Aのデータを削除してからTABLE_Aにコピーする。データがなければ、TABLE_Aの現在のデータを生成した文字列をZUTY_TESTCASE_NAMEに指定してZUTY_TABLE_Aに保存して、上記のテスト失敗エラーを発生させる。

この動作により、上記の自動的に保存されたデータは次回テスト実行時にはテストデータとして自動的に読み込まれるようになります。<br>
なお、ZUTY_TABLE_Aに保存されたデータに問題が発覚した場合には、直接編集するか、上記テスト失敗メッセージ内にある、
{{{
DELETE FROM ZUTY_TABLE_A WHERE ZUTY_TESTCASE_NAME = 'atest.prepare#sample.ADBTest'
}}}
というDELETE文を実行し、テストデータを削除してやり直してください。

deleteDBメソッドは指定されたテーブルに対して「ZUTY`_`...」というテーブルを自動生成してバックアップを取るところまではprepareDBと同じですが、その後に指定されたテーブルのデータを削除するところが違います。テスト開始時点でデータを0件にしたいテーブルに対して使用します。<br>
ここではTABLE_Bに対してZUTY_TABLE_Bというテーブルが生成されて、バックアップデータが保存されます。

テストデータの準備が終わったら、テスト対象クラスを実行します。<br>
ここでは_TestTarget.moveDatasFromTableAToTableB _というメソッドがテスト対象です。<br>
テスト対象クラスの動作内容は、メソッド名の通りTABLE_Aのデータを全てTABLE_Bにコピーし、TABLE_Aのデータを削除するものだとして以下の説明を続けます。

== テスト結果の検証 ==



{{{
java.lang.AssertionError: No expected data found. Tried to insert some datas as expected data.
Please check it by the SQL below:
SELECT * FROM ZUTY_TABLE_B WHERE ZUTY_TESTCASE_NAME = 'atest.expected#sample.ADBTest'
If you don't like it, delete it by the SQL below:
DELETE FROM ZUTY_TABLE_B WHERE ZUTY_TESTCASE_NAME = 'atest.expected#sample.ADBTest'
	at org.junit.Assert.fail(Assert.java:91)
	at tetz42.test.AutyDB.assertDB(AutyDB.java:100)
	at tetz42.test.AutyDB.assertDB(AutyDB.java:82)
	at sample.ADBTest$1.run(ADBTest.java:38)
	at tetz42.test.AutyDB.useConnection(AutyDB.java:53)
	at sample.ADBTest.atest(ADBTest.java:19)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                      :
                      :
}}}

